'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AuthClient = exports.deleteResource = exports.updateResource = exports.getResource = exports.getResources = exports.createResource = exports.deleteUser = exports.updateUser = exports.getUser = exports.getUsers = exports.createUser = exports.checkAccess = exports.verifyToken = exports.getToken = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let handleError = (() => {
	var _ref = _asyncToGenerator(function* (response) {
		if (!response.ok) {
			let err;
			const contentType = response.headers.get('content-type');
			if (contentType === 'application/json') {
				let errObj = yield response.json();
				err = new Error();
				Object.keys(errObj).forEach(function (key) {
					err[key] = errObj[key];
				});
			} else err = new Error((yield response.text()));
			err.status = response.status;
			throw err;
		}
	});

	return function handleError(_x) {
		return _ref.apply(this, arguments);
	};
})();

let getToken = exports.getToken = (() => {
	var _ref2 = _asyncToGenerator(function* (authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/token`, {
			method: 'GET',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function getToken(_x2, _x3) {
		return _ref2.apply(this, arguments);
	};
})();

let verifyToken = exports.verifyToken = (() => {
	var _ref3 = _asyncToGenerator(function* (token, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/token/verification`, {
			method: 'POST',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			}),
			body: JSON.stringify({ token })
		});
		yield handleError(response);
		return yield response.json();
	});

	return function verifyToken(_x4, _x5, _x6) {
		return _ref3.apply(this, arguments);
	};
})();

let checkAccess = exports.checkAccess = (() => {
	var _ref4 = _asyncToGenerator(function* (userAuthorization, domain, method, path, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/auth`, {
			method: 'POST',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			}),
			body: JSON.stringify({
				authorization: userAuthorization,
				method,
				domain,
				path
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function checkAccess(_x7, _x8, _x9, _x10, _x11, _x12) {
		return _ref4.apply(this, arguments);
	};
})();

let createUser = exports.createUser = (() => {
	var _ref5 = _asyncToGenerator(function* (user, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/users`, {
			method: 'POST',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			}),
			body: JSON.stringify({ user })
		});
		yield handleError(response);
		return yield response.json();
	});

	return function createUser(_x13, _x14, _x15) {
		return _ref5.apply(this, arguments);
	};
})();

let getUsers = exports.getUsers = (() => {
	var _ref6 = _asyncToGenerator(function* (authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/users`, {
			method: 'GET',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function getUsers(_x16, _x17) {
		return _ref6.apply(this, arguments);
	};
})();

let getUser = exports.getUser = (() => {
	var _ref7 = _asyncToGenerator(function* (userId, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/users/${userId}`, {
			method: 'GET',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function getUser(_x18, _x19, _x20) {
		return _ref7.apply(this, arguments);
	};
})();

let updateUser = exports.updateUser = (() => {
	var _ref8 = _asyncToGenerator(function* (userId, user, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/users/${userId}`, {
			method: 'PUT',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			}),
			body: JSON.stringify({ user })
		});
		yield handleError(response);
		return yield response.json();
	});

	return function updateUser(_x21, _x22, _x23, _x24) {
		return _ref8.apply(this, arguments);
	};
})();

let deleteUser = exports.deleteUser = (() => {
	var _ref9 = _asyncToGenerator(function* (userId, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/users/${userId}`, {
			method: 'DELETE',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function deleteUser(_x25, _x26, _x27) {
		return _ref9.apply(this, arguments);
	};
})();

let createResource = exports.createResource = (() => {
	var _ref10 = _asyncToGenerator(function* (resource, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/resources`, {
			method: 'POST',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			}),
			body: JSON.stringify({ resource })
		});
		yield handleError(response);
		return yield response.json();
	});

	return function createResource(_x28, _x29, _x30) {
		return _ref10.apply(this, arguments);
	};
})();

let getResources = exports.getResources = (() => {
	var _ref11 = _asyncToGenerator(function* (authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/resources`, {
			method: 'GET',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function getResources(_x31, _x32) {
		return _ref11.apply(this, arguments);
	};
})();

let getResource = exports.getResource = (() => {
	var _ref12 = _asyncToGenerator(function* (resourceId, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/resources/${resourceId}`, {
			method: 'GET',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function getResource(_x33, _x34, _x35) {
		return _ref12.apply(this, arguments);
	};
})();

let updateResource = exports.updateResource = (() => {
	var _ref13 = _asyncToGenerator(function* (resourceId, resource, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/resources/${resourceId}`, {
			method: 'PUT',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			}),
			body: JSON.stringify({ resource })
		});
		yield handleError(response);
		return yield response.json();
	});

	return function updateResource(_x36, _x37, _x38, _x39) {
		return _ref13.apply(this, arguments);
	};
})();

let deleteResource = exports.deleteResource = (() => {
	var _ref14 = _asyncToGenerator(function* (resourceId, authorization, server) {
		let response = yield (0, _crossFetch2.default)(`${server}/api/resources/${resourceId}`, {
			method: 'DELETE',
			headers: _extends({}, authorization ? { 'Authorization': authorization } : {}, {
				'content-type': 'application/json'
			})
		});
		yield handleError(response);
		return yield response.json();
	});

	return function deleteResource(_x40, _x41, _x42) {
		return _ref14.apply(this, arguments);
	};
})();

var _crossFetch = require('cross-fetch');

var _crossFetch2 = _interopRequireDefault(_crossFetch);

var _jsonwebtoken = require('jsonwebtoken');

var _jsonwebtoken2 = _interopRequireDefault(_jsonwebtoken);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Function.prototype.$asyncbind = function $asyncbind(self, catcher) {
	"use strict";

	if (!Function.prototype.$asyncbind) {
		Object.defineProperty(Function.prototype, "$asyncbind", {
			value: $asyncbind,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}

	if (!$asyncbind.trampoline) {
		$asyncbind.trampoline = function trampoline(t, x, s, e, u) {
			return function b(q) {
				while (q) {
					if (q.then) {
						q = q.then(b, e);
						return u ? undefined : q;
					}

					try {
						if (q.pop) {
							if (q.length) return q.pop() ? x.call(t) : q;
							q = s;
						} else q = q.call(t);
					} catch (r) {
						return e(r);
					}
				}
			};
		};
	}

	if (!$asyncbind.LazyThenable) {
		$asyncbind.LazyThenable = function () {
			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === "function";
			}

			function resolution(p, r, how) {
				try {
					var x = how ? how(r) : r;
					if (p === x) return p.reject(new TypeError("Promise resolution loop"));

					if (isThenable(x)) {
						x.then(function (y) {
							resolution(p, y);
						}, function (e) {
							p.reject(e);
						});
					} else {
						p.resolve(x);
					}
				} catch (ex) {
					p.reject(ex);
				}
			}

			function Chained() {}

			;
			Chained.prototype = {
				resolve: _unchained,
				reject: _unchained,
				then: thenChain
			};

			function _unchained(v) {}

			function thenChain(res, rej) {
				this.resolve = res;
				this.reject = rej;
			}

			function then(res, rej) {
				var chain = new Chained();

				try {
					this._resolver(function (value) {
						return isThenable(value) ? value.then(res, rej) : resolution(chain, value, res);
					}, function (ex) {
						resolution(chain, ex, rej);
					});
				} catch (ex) {
					resolution(chain, ex, rej);
				}

				return chain;
			}

			function Thenable(resolver) {
				this._resolver = resolver;
				this.then = then;
			}

			;

			Thenable.resolve = function (v) {
				return Thenable.isThenable(v) ? v : {
					then: function (resolve) {
						return resolve(v);
					}
				};
			};

			Thenable.isThenable = isThenable;
			return Thenable;
		}();

		$asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = function (tick) {
			tick = tick || typeof process === "object" && process.nextTick || typeof setImmediate === "function" && setImmediate || function (f) {
				setTimeout(f, 0);
			};

			var soon = function () {
				var fq = [],
				    fqStart = 0,
				    bufferSize = 1024;

				function callQueue() {
					while (fq.length - fqStart) {
						try {
							fq[fqStart]();
						} catch (ex) {}

						fq[fqStart++] = undefined;

						if (fqStart === bufferSize) {
							fq.splice(0, bufferSize);
							fqStart = 0;
						}
					}
				}

				return function (fn) {
					fq.push(fn);
					if (fq.length - fqStart === 1) tick(callQueue);
				};
			}();

			function Zousan(func) {
				if (func) {
					var me = this;
					func(function (arg) {
						me.resolve(arg);
					}, function (arg) {
						me.reject(arg);
					});
				}
			}

			Zousan.prototype = {
				resolve: function (value) {
					if (this.state !== undefined) return;
					if (value === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
					var me = this;

					if (value && (typeof value === "function" || typeof value === "object")) {
						try {
							var first = 0;
							var then = value.then;

							if (typeof then === "function") {
								then.call(value, function (ra) {
									if (!first++) {
										me.resolve(ra);
									}
								}, function (rr) {
									if (!first++) {
										me.reject(rr);
									}
								});
								return;
							}
						} catch (e) {
							if (!first) this.reject(e);
							return;
						}
					}

					this.state = STATE_FULFILLED;
					this.v = value;
					if (me.c) soon(function () {
						for (var n = 0, l = me.c.length; n < l; n++) STATE_FULFILLED(me.c[n], value);
					});
				},
				reject: function (reason) {
					if (this.state !== undefined) return;
					this.state = STATE_REJECTED;
					this.v = reason;
					var clients = this.c;
					if (clients) soon(function () {
						for (var n = 0, l = clients.length; n < l; n++) STATE_REJECTED(clients[n], reason);
					});
				},
				then: function (onF, onR) {
					var p = new Zousan();
					var client = {
						y: onF,
						n: onR,
						p: p
					};

					if (this.state === undefined) {
						if (this.c) this.c.push(client);else this.c = [client];
					} else {
						var s = this.state,
						    a = this.v;
						soon(function () {
							s(client, a);
						});
					}

					return p;
				}
			};

			function STATE_FULFILLED(c, arg) {
				if (typeof c.y === "function") {
					try {
						var yret = c.y.call(undefined, arg);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.resolve(arg);
			}

			function STATE_REJECTED(c, reason) {
				if (typeof c.n === "function") {
					try {
						var yret = c.n.call(undefined, reason);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.reject(reason);
			}

			Zousan.resolve = function (val) {
				if (val && val instanceof Zousan) return val;
				var z = new Zousan();
				z.resolve(val);
				return z;
			};

			Zousan.reject = function (err) {
				if (err && err instanceof Zousan) return err;
				var z = new Zousan();
				z.reject(err);
				return z;
			};

			Zousan.version = "2.3.3-nodent";
			return Zousan;
		})();
	}

	var resolver = this;

	switch (catcher) {
		case true:
			return new $asyncbind.Thenable(boundThen);

		case 0:
			return new $asyncbind.LazyThenable(boundThen);

		case undefined:
			boundThen.then = boundThen;
			return boundThen;

		default:
			return function () {
				try {
					return resolver.apply(self, arguments);
				} catch (ex) {
					return catcher(ex);
				}
			};
	}

	function boundThen() {
		return resolver.apply(self, arguments);
	}
};

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = options => (() => {
	var _ref15 = _asyncToGenerator(function* (ctx, next) {
		const { domain, server, authorization } = options;
		const { header: { authorization: userAuthorization }, query: { accessToken }, method, path } = ctx;
		const { user, iss, oneTime } = yield checkAccess(userAuthorization || `Bearer ${accessToken}`, domain, method, path, authorization, server);
		ctx.state.user = user;
		ctx.state.iss = iss;
		ctx.state.oneTime = oneTime;
		return next();
	});

	return function (_x43, _x44) {
		return _ref15.apply(this, arguments);
	};
})();

let AuthClient = exports.AuthClient = class AuthClient {

	constructor(options) {
		var _this = this;

		this.getToken = () => getToken(this.authorization, this.server);

		this.verifyToken = token => verifyToken(token, this.authorization, this.server);

		this.checkAccess = (userAuthorization, domain, method, path) => checkAccess(userAuthorization, domain, method, path, this.authorization, this.server);

		this.createResource = resource => createResource(resource, this.authorization, this.server);

		this.getResources = () => getResources(this.authorization, this.server);

		this.getResource = resourceId => getResource(resourceId, this.authorization, this.server);

		this.updateResource = (resourceId, resource) => updateResource(resourceId, resource, this.authorization, this.server);

		this.deleteResource = resourceId => deleteResource(resourceId, this.authorization, this.server);

		this.createUser = user => createUser(user, this.authorization, this.server);

		this.getUsers = () => getUsers(this.authorization, this.server);

		this.getUser = userId => getUser(userId, this.authorization, this.server);

		this.updateUser = (userId, user) => updateUser(userId, user, this.authorization, this.server);

		this.deleteUser = userId => deleteUser(userId, this.authorization, this.server);

		let { authorization, server, tokenRefreshPeriod = 10000 } = options;
		if (typeof authorization === 'object') {
			const { user = '', pass = '' } = authorization;
			const userpass = Buffer.from(`${user}:${pass}`).toString('base64');
			authorization = `Basic ${userpass}`;
		}
		this._authorization = authorization;
		this.authorization = authorization;
		this.server = server;
		this.tokenRefreshPeriod = tokenRefreshPeriod;

		if (tokenRefreshPeriod > 0) {
			this.authorizationRefreshInterval = setInterval(_asyncToGenerator(function* () {
				if (_this.token) {
					if (Math.floor(Date.now() / 1000) < _this.tokenExp) return;
				}
				try {
					let { token } = yield _this.getToken();
					_this.token = token;
					_this.tokenExp = _jsonwebtoken2.default.decode(token).exp;
					_this.authorization = `Bearer ${token}`;
				} catch (err) {
					_this.token = null;
					_this.tokenExp = null;
					_this.authorization = _this._authorization;
				}
			}), tokenRefreshPeriod);
		}
	}

};